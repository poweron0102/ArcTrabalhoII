---
cssclasses: []
---
# Cap√≠tulo 1: Introdu√ß√£o
Abordaremos a import√¢ncia do estudo e da simula√ß√£o de arquiteturas de processadores, com foco particular na arquitetura MIPS64 e na ferramenta EduMIPS64. A compreens√£o dos processadores e suas opera√ß√µes √© essencial para estudantes e profissionais de engenharia da computa√ß√£o, pois permite o desenvolvimento de software mais eficiente e a otimiza√ß√£o de sistemas de hardware.

## Objetivo do Estudo
O objetivo principal deste estudo √© explorar e analisar a arquitetura do processador MIPS64, utilizando a ferramenta de simula√ß√£o EduMIPS64. Atrav√©s de simula√ß√µes e question√°rios, buscamos entender melhor o funcionamento interno dos processadores, a execu√ß√£o de instru√ß√µes, a gest√£o de ciclos de rel√≥gio e a efici√™ncia do c√≥digo executado. Este conhecimento √© crucial para otimizar programas, melhorando seu desempenho e efici√™ncia.
# Cap√≠tulo 2: Descri√ß√£o da ferramenta Edumips64
## Principais Caracter√≠sticas do EduMIPS64
### Interface Gr√°fica
A interface gr√°fica do EduMIPS64 √© projetada para ser amig√°vel e interativa, ajudando os estudantes a compreenderem melhor o funcionamento interno de um processador MIPS64. A interface inclui:

Janela de Registros: Exibe o estado atual dos registros do processador.
Janela de Mem√≥ria: Mostra o conte√∫do da mem√≥ria principal.
Painel de Controle: Para iniciar, pausar e depurar a execu√ß√£o do programa.
Simula√ß√£o e Depura√ß√£o
As configura√ß√µes do EduMIPS64 s√£o acess√≠veis atrav√©s de um menu dedicado, onde os usu√°rios podem ajustar par√¢metros do simulador.
# Cap√≠tulo 3: Question√°rio
## Quest√£o 1
üëç
## Quest√£o 2
**Cycles = 350**
√â o n√∫mero de ciclos de rel√≥gio que o programa levou para completar sua execu√ß√£o.

**Instructions = 201**
√â o n√∫mero de instru√ß√µes executadas durante a execu√ß√£o do programa.

**CPI = 1.741**
√â a a raz√£o entre o n√∫mero de ciclos e o n√∫mero de instru√ß√µes, que equivale ao n√∫mero m√©dio de ciclos do rel√≥gio que cada instru√ß√£o leva para ser executada.

**Stalls = 105**
A quantidade de ciclos do rel√≥gio em que a execu√ß√£o do programa foi atrasada para evitar os riscos da pipeline.
## Quest√£o 3
Houve 105 paradas por conflitos do tipo Read After Write.
## Quest√£o 4
üëç
## Quest√£o 5
üëç
## Quest√£o 6
**Cycles = 245**
√â o n√∫mero de ciclos de rel√≥gio que o programa levou para completar sua execu√ß√£o.

**Instructions = 201**
√â o n√∫mero de instru√ß√µes executadas durante a execu√ß√£o do programa.

**CPI = 1.218**
√â a a raz√£o entre o n√∫mero de ciclos e o n√∫mero de instru√ß√µes, que equivale ao n√∫mero m√©dio de ciclos do rel√≥gio que cada instru√ß√£o leva para ser executada.

**Stalls = 0**
A quantidade de ciclos do rel√≥gio em que a execu√ß√£o do programa foi atrasada para evitar os riscos da pipeline.
## Quest√£o 7
Depois que o adiantamento foi acionado, n√£o houve nenhuma parada por conflito.
## Quest√£o 8
A quantidade de instru√ß√µes nos itens 2 e 6 foram a mesma, j√° que o algoritmo n√£o mudou. No item 6 n√£o houve paradas por conflito, em contraste com o item 2, onde aconteceram 105. Isso se d√° pelo mecanismo de adiantamento que permite que os dados pulem est√°gios da pipeline para evitar esperas. Como v√°rios ciclos de rel√≥gio foram perdidos em stalls no item 2, o n√∫mero de ciclos e, consequentemente, a CPI, foram bem menores no item 6.
## Quest√£o 9
üëç
## Quest√µes 10-11
### Sem Adiantamento
#### Instructions:
3 instru√ß√µes s√£o executadas inicialmente, 8 dentro do loop, e 1 instru√ß√£o de parada no final. O loop passa por uma itera√ß√£o para cada um dos 128 elementos do array. Portanto, temos que o n√∫mero de instru√ß√µes ser√°:
$$
{4}+({8}\times{128}) = 1028
$$
#### Stalls:
```
main:¬†
¬† ¬† DADDI R3,R0,8 ¬† ¬† ¬† ¬† ¬† ¬† ¬† ;1
¬† ¬† DADDI R1,R0,1024 ¬† ¬† ¬† ¬† ¬† ¬†;2 ¬† ¬† ¬† ¬† ¬†
¬† ¬† DADDI R2,R0,1024 ¬† ¬† ¬† ¬† ¬† ¬†;3 ¬† ¬† ¬† ¬† ¬† ¬†
Loop: ¬† ¬† ¬† ¬† ¬†
¬† ¬† L.D F0,0(R1) ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†;4
¬† ¬† MUL.D F0,F0,F2 ¬† ¬† ¬† ¬† ¬† ¬† ¬†;5
¬† ¬† L.D F4,0(R2) ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†;6
¬† ¬† ADD.D F0,F0,F4 ¬† ¬† ¬† ¬† ¬† ¬† ¬†;7
¬† ¬† S.D F0,0(R2) ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†;8
¬† ¬† DSUB R1,R1,R3 ¬† ¬† ¬† ¬† ¬† ¬† ¬† ;9
¬† ¬† DSUB R2,R2,R3 ¬† ¬† ¬† ¬† ¬† ¬† ¬† ;10
BNEZ R1,Loop ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†;11
HALT ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†;12
```

Antes do loop
2 e 4: 1 ciclo (evit√°vel com forwarding)

Dentro do Loop:
4 e 5: 2 ciclos. (1 evit√°vel com forwarding)
5 e 7: 7 ciclos. (2 s√£o evit√°veis com forwarding)
7 e 8: 5 ciclos  (2 s√£o evit√°veis com forwarding)
9 e 11: 1 ciclo (evit√°vel com forwarding)

Total = 128 x (15) + 1 = 1921

#### Cycles
4 ciclos para encher a pipeline
1028 ciclos onde uma nova instru√ß√£o √© buscada
1921 ciclos onde ocorre um stall
1 ciclo de esvaziamento da pipeline para cada uma das 127 itera√ß√µes do loop em que R1 era diferente de zero.

Total = 4 + 1028 + 1921 + 1*(128-1) = 3080 ciclos

#### CPI
$$
\frac{3080}{1028} \approx 2.99
$$
### Com Adiantamento
#### Instructions:
Mesma quantidade: 1028 instru√ß√µes.

#### Stalls:
```
main:¬†
¬† ¬† DADDI R3,R0,8 ¬† ¬† ¬† ¬† ¬† ¬† ¬† ;1
¬† ¬† DADDI R1,R0,1024 ¬† ¬† ¬† ¬† ¬† ¬†;2 ¬† ¬† ¬† ¬† ¬†
¬† ¬† DADDI R2,R0,1024 ¬† ¬† ¬† ¬† ¬† ¬†;3 ¬† ¬† ¬† ¬† ¬† ¬†
Loop: ¬† ¬† ¬† ¬† ¬†
¬† ¬† L.D F0,0(R1) ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†;4
¬† ¬† MUL.D F0,F0,F2 ¬† ¬† ¬† ¬† ¬† ¬† ¬†;5
¬† ¬† L.D F4,0(R2) ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†;6
¬† ¬† ADD.D F0,F0,F4 ¬† ¬† ¬† ¬† ¬† ¬† ¬†;7
¬† ¬† S.D F0,0(R2) ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†;8
¬† ¬† DSUB R1,R1,R3 ¬† ¬† ¬† ¬† ¬† ¬† ¬† ;9
¬† ¬† DSUB R2,R2,R3 ¬† ¬† ¬† ¬† ¬† ¬† ¬† ;10
BNEZ R1,Loop ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†;11
HALT ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬† ¬†;12
```

Dentro do Loop:
4 e 5: 1 RAW
5 e 7: 5 RAW
5 e 7: 1 WAW
7 e 8: 3 RAW

Total = 128 x (1+5+3) RAW + 128 x 1 WAW = 1152 RAW e 128 WAW = 1280 Stalls.


#### Cycles
4 ciclos para encher a pipeline
1028 ciclos onde uma nova instru√ß√£o √© buscada
1280 ciclos onde ocorre um stall
1 ciclo de esvaziamento da pipeline para cada uma das 127 itera√ß√µes do loop em que R1 era diferente de zero.

Total = 4 + 1028 + 1280 + 1*(128-1) = 2439 ciclos.


#### CPI
$$
\frac{2439}{1028} \approx 2.37
$$
## Quest√£o 12
üëç
## Quest√£o 13
S√£o iguais.
## Quest√£o 14
Houve parada por conflito. Sem o adiantamento de dados, tivemos 1921 Stalls do tipo RAW. Com o adiantamento de dados habilitado, algumas dessas paradas foram eliminadas, mas novos stalls do tipo WAW foram introduzidos, somando um total de 1280 Stalls (1152 RAW e 128 WAW).
## Quest√£o 15
O n√∫mero de instru√ß√µes permanece o mesmo nas duas execu√ß√µes, j√° que o algoritmo n√£o foi alterado. A quantidade total de stalls diminui com o adiantamento de dados, j√° que v√°rias paradas do tipo RAW s√£o evitadas pela t√©cnica. Isso acarreta na diminui√ß√£o da quantidade de ciclos que o programa leva para completar a execu√ß√£o, que por sua vez implica na diminui√ß√£o da CPI.
## Quest√£o 16
Sim. √â poss√≠vel evitar as paradas da pipeline rearrumando as instru√ß√µes de forma que as instru√ß√µes com depend√™ncia de dados fiquem mais distantes uma da outra.
## Quest√£o 17
> [!info] Adicionamos um vetor de teste, assim como um valor arbitr√°rio para F2, com o prop√≥sito de testar o programa.
```
.data
vet: ¬† ¬†.double 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0, 27.0, 28.0, 29.0, 30.0, 31.0, 32.0, 33.0, 34.0, 35.0, 36.0, 37.0, 38.0, 39.0, 40.0, 41.0, 42.0, 43.0, 44.0, 45.0, 46.0, 47.0, 48.0, 49.0, 50.0, 51.0, 52.0, 53.0, 54.0, 55.0, 56.0, 57.0, 58.0, 59.0, 60.0, 61.0, 62.0, 63.0, 64.0, 65.0, 66.0, 67.0, 68.0, 69.0, 70.0, 71.0, 72.0, 73.0, 74.0, 75.0, 76.0, 77.0, 78.0, 79.0, 80.0, 81.0, 82.0, 83.0, 84.0, 85.0, 86.0, 87.0, 88.0, 89.0, 90.0, 91.0, 92.0, 93.0, 94.0, 95.0, 96.0, 97.0, 98.0, 99.0, 100.0, 101.0, 102.0, 103.0, 104.0, 105.0, 106.0, 107.0, 108.0, 109.0, 110.0, 111.0, 112.0, 113.0, 114.0, 115.0, 116.0, 117.0, 118.0, 119.0, 120.0, 121.0, 122.0, 123.0, 124.0, 125.0, 126.0, 127.0

constant: .double 2.0

.text
main:
¬† ¬† L.D F2, constant(R0)
¬† ¬† DADDI R3,R0,8
¬† ¬† DADDI R1,R0,1024
¬† ¬† DADDI R2,R0,1024
Loop:
¬† ¬† L.D F0,0(R1)
¬† ¬† L.D F4,0(R2)
¬† ¬† MUL.D F0,F0,F2
¬† ¬† DSUB R1,R1,R3
¬† ¬† DSUB R2,R2,R3
¬† ¬† ADD.D F0,F0,F4
¬† ¬† S.D F0,8(R2)
BNEZ R1,Loop
HALT
```
### Cycles
Sem adiantamento: 2697 ciclos
Com adiantamento: 2184 ciclos
O n√∫mero de ciclos diminui com o adiantamento pois menos ciclos s√£o desperdi√ßados com stalls.
### Instructions
Sem adiantamento: 1029 instru√ß√µes
Com adiantamento: 1029 instru√ß√µes
Nenhuma diferen√ßa era esperada, j√° que o algoritmo √© o mesmo.
### CPI
Sem adiantamento: 2.620 ciclos por instru√ß√£o
Com adiantamento: 2.122 ciclos por instru√ß√£o
A CPI diminui bastante com o adiantamento, j√° que o n√∫mero de ciclos diminui e a quantidade de instru√ß√µes permanece a mesma.
### Stalls
Sem adiantamento: 1537 Stalls (RAW)
Com adiantamento: 1024 Stalls (896 RAW e 128 WAW)
H√° uma diminui√ß√£o substancial nos stalls RAW, j√° que a pipeline n√£o precisa esperar os est√°gios MEM e WB antes de cada acesso p√≥s-escrita. Alguns desses stalls, no entanto, s√£o substitu√≠dos por WAW.
## Quest√£o 18
> [!info] Adicionamos um vetor de teste, assim como um valor arbitr√°rio para F2, com o prop√≥sito de testar o programa.

> [!warning] O loop opera de 7 em 7 elementos para agrupar ao m√°ximo (dentro do limite de registradores dispon√≠veis) as instru√ß√µes similares, evitando stalls. N√£o usamos a capacidade m√°xima de 8 elementos por loop porque o registrador F2 √© reservado para a constante inicial. Como 7 n√£o √© divisor do tamanho do array, operamos nos 2 elementos que sobraram fora do loop.

```
.data
vet: ¬† ¬†.double 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0, 26.0, 27.0, 28.0, 29.0, 30.0, 31.0, 32.0, 33.0, 34.0, 35.0, 36.0, 37.0, 38.0, 39.0, 40.0, 41.0, 42.0, 43.0, 44.0, 45.0, 46.0, 47.0, 48.0, 49.0, 50.0, 51.0, 52.0, 53.0, 54.0, 55.0, 56.0, 57.0, 58.0, 59.0, 60.0, 61.0, 62.0, 63.0, 64.0, 65.0, 66.0, 67.0, 68.0, 69.0, 70.0, 71.0, 72.0, 73.0, 74.0, 75.0, 76.0, 77.0, 78.0, 79.0, 80.0, 81.0, 82.0, 83.0, 84.0, 85.0, 86.0, 87.0, 88.0, 89.0, 90.0, 91.0, 92.0, 93.0, 94.0, 95.0, 96.0, 97.0, 98.0, 99.0, 100.0, 101.0, 102.0, 103.0, 104.0, 105.0, 106.0, 107.0, 108.0, 109.0, 110.0, 111.0, 112.0, 113.0, 114.0, 115.0, 116.0, 117.0, 118.0, 119.0, 120.0, 121.0, 122.0, 123.0, 124.0, 125.0, 126.0, 127.0
constant: .double 2.0
.text
main:
¬† ¬† DADDI R1, R0, 1008 
¬† ¬† DADDI R2, R0, 1008 ¬† 
¬† ¬† L.D F2, constant(R0) ¬†
¬† ¬† ; Fazer opera√ß√µes nos elementos 128 e 127 do array antes de iniciar o loop.
	¬† ¬† L.D F0, 8(R1)
	¬† ¬† L.D F4, 16(R1)
	¬† ¬† L.D F16, 8(R2)
	¬† ¬† L.D F18, 16(R2)
	¬† ¬† MUL.D F0, F0, F2
	¬† ¬† MUL.D F4, F4, F2
	¬† ¬† DADDI R4, R0, 56   ;Colocando esta instru√ß√£o aqui, reduzimos o n√∫mero de stalls em 1.¬† 
	¬† ¬† ADD.D F0, F0, F16
	¬† ¬† ADD.D F4, F4, F18
	¬† ¬† S.D F0, 8(R2)
	¬† ¬† S.D F4, 16(R2)
Loop:
¬† ¬† ; Carrega 7 elementos do endere√ßo R1
	¬† ¬† L.D F0, 0(R1)
	¬† ¬† L.D F4, -8(R1)
	¬† ¬† L.D F6, -16(R1)
	¬† ¬† L.D F8, -24(R1)
	¬† ¬† L.D F10, -32(R1)
	¬† ¬† L.D F12, -40(R1)
	¬† ¬† L.D F14, -48(R1)
¬† ¬† ; Carrega 7 elementos do endere√ßo R2
	¬† ¬† L.D F16, 0(R2)
	¬† ¬† L.D F18, -8(R2)
	¬† ¬† L.D F20, -16(R2)
	¬† ¬† L.D F22, -24(R2)
	¬† ¬† L.D F24, -32(R2)
	¬† ¬† L.D F26, -40(R2)
	¬† ¬† L.D F28, -48(R2)
¬† ¬† ; Atualiza R1 e R2 para a pr√≥xima itera√ß√£o
	¬† ¬† DSUB R1, R1, R4
	¬† ¬† DSUB R2, R2, R4
¬† ¬† ; Multiplica elementos por F2
	¬† ¬† MUL.D F0, F0, F2
	¬† ¬† MUL.D F4, F4, F2
	¬† ¬† MUL.D F6, F6, F2
	¬† ¬† MUL.D F8, F8, F2
	¬† ¬† MUL.D F10, F10, F2
	¬† ¬† MUL.D F12, F12, F2
	¬† ¬† MUL.D F14, F14, F2
¬† ¬† ; Adicionar elementos correspondentes de R2
	¬† ¬† ADD.D F0, F0, F16	
	¬† ¬† ADD.D F4, F4, F18	
	¬† ¬† ADD.D F6, F6, F20	
	¬† ¬† ADD.D F8, F8, F22	
	¬† ¬† ADD.D F10, F10, F24	
	¬† ¬† ADD.D F12, F12, F26	
	¬† ¬† ADD.D F14, F14, F28
¬† ¬† ; Guardar os resultados na mem√≥ria
	¬† ¬† S.D F0, 56(R2)	
	¬† ¬† S.D F4, 48(R2)	
	¬† ¬† S.D F6, 40(R2)
	¬† ¬† S.D F8, 32(R2)
	¬† ¬† S.D F10, 24(R2)
	¬† ¬† S.D F12, 16(R2)
	¬† ¬† S.D F14, 8(R2)
BNEZ R1, Loop
HALT
```
## Quest√£o 19
### Cycles
Sem adiantamento: 838 ciclos
Com adiantamento: 836 ciclos
O n√∫mero de ciclos diminui com o adiantamento pois menos ciclos s√£o desperdi√ßados com stalls.
### Instructions
Sem adiantamento: 699 instru√ß√µes
Com adiantamento: 699 instru√ß√µes
Nenhuma diferen√ßa era esperada, j√° que o algoritmo √© o mesmo.
### CPI
Sem adiantamento: 1.198 ciclos por instru√ß√£o
Com adiantamento: 1.195 ciclos por instru√ß√£o
A CPI diminui bastante com o adiantamento, j√° que o n√∫mero de ciclos diminui e a quantidade de instru√ß√µes permanece a mesma.
### Stalls
Sem adiantamento: 100 Stalls (46 RAW e 54 estruturais de mem√≥ria)
Com adiantamento: 80 Stalls (6 RAW e 19 WAW, 55 estruturais de mem√≥ria)
H√° uma diminui√ß√£o substancial nos stalls RAW, j√° que a pipeline n√£o precisa esperar os est√°gios MEM e WB antes de cada acesso p√≥s-escrita. Alguns desses stalls, no entanto, s√£o substitu√≠dos por WAW.
## Quest√£o 20
### Instructions
#### Original
Sem adiantamento: 1029 instru√ß√µes (1 para o teste)
Com adiantamento: 1029 instru√ß√µes (1 para o teste)
#### Reordenado
Sem adiantamento: 1029 instru√ß√µes (1 para o teste)
Com adiantamento: 1029 instru√ß√µes (1 para o teste)
#### Desenrolado
Sem adiantamento: 699 instru√ß√µes (1 para o teste)
Com adiantamento: 699 instru√ß√µes (1 para o teste)
### Stalls
#### Original
Sem adiantamento: 1921 Stalls (RAW)
Com adiantamento: 1280 Stalls (1152 RAW e 128 WAW)
#### Reordenado
Sem adiantamento: 1537 Stalls (RAW)
Com adiantamento: 1024 Stalls (896 RAW e 128 WAW)
#### Desenrolado
Sem adiantamento: 100 Stalls (46 RAW e 54 estruturais de mem√≥ria)
Com adiantamento: 80 Stalls (6 RAW e 19 WAW, 55 estruturais de mem√≥ria)
### Cycles
#### Original
Sem adiantamento: 3080 ciclos
Com adiantamento: 2439 ciclos
#### Reordenado
Sem adiantamento: 2697 ciclos
Com adiantamento: 2184 ciclos
#### Desenrolado
Sem adiantamento: 838
Com adiantamento: 836
### CPI
#### Original
Sem adiantamento: 2.99
Com adiantamento: 2.37
#### Reordenado
Sem adiantamento: 2.620
Com adiantamento: 2.122
#### Desenrolado
Sem adiantamento: 1.198
Com adiantamento: 1.195

### An√°lise
## Instructions
A quantidade de instru√ß√µes n√£o varia entre os cen√°rios original, reordenado e desenrolado, com exce√ß√£o do c√≥digo desenrolado, onde h√° uma redu√ß√£o significativa no n√∫mero de instru√ß√µes.
Essa redu√ß√£o no c√≥digo desenrolado reflete a diminui√ß√£o das instru√ß√µes de controle de loop devido ao desenrolamento de loops, o que melhora a efici√™ncia ao reduzir o overhead das instru√ß√µes de controle.

## Stalls
A reordena√ß√£o e o desenrolamento de loops s√£o eficazes em reduzir o n√∫mero de stalls, particularmente os stalls RAW. A introdu√ß√£o do adiantamento tamb√©m mostra uma redu√ß√£o significativa nos stalls, especialmente no cen√°rio original e reordenado.

## Cycles
O c√≥digo desenrolado √© significativamente mais eficiente, necessitando de muito menos ciclos para a execu√ß√£o. O adiantamento melhora o desempenho em todos os casos, mas √© mais impactante no c√≥digo original e reordenado do que no desenrolado

## CPI
O CPI do c√≥digo desenrolado √© significativamente menor, indicando uma execu√ß√£o mais eficiente das instru√ß√µes. O adiantamento tamb√©m reduz o CPI em todos os casos, sendo mais eficaz em cen√°rios com maior n√∫mero de stalls.

## Resumo
O desenrolamento de loops e a reordena√ß√£o de instru√ß√µes s√£o t√©cnicas poderosas para otimizar o c√≥digo, reduzindo significativamente o n√∫mero de ciclos e o CPI. As t√©cnicas de adiantamento complementam essas otimiza√ß√µes, reduzindo ainda mais os stalls e melhorando a efici√™ncia da execu√ß√£o. No entanto, a efic√°cia do adiantamento √© mais evidente em c√≥digos com maior n√∫mero de depend√™ncias e stalls, como no caso do c√≥digo original e reordenado.